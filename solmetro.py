# -*- coding: utf-8 -*-
"""SOLMETRO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CVRdw7qJkLBIRbZKoVBvPrbQ9BZ_8wMd
"""

import numpy as np
import random
import matplotlib.pyplot as plt
from scipy import stats  # For skewed normal distribution

class Entrance:
  def __init__(self, initialPeople = 100):
    self.quantity = initialPeople

  def enterEntrance(self, amount, source):
    self.quantity += amount
    print(f"{amount} people entered the entrance from {source}")

  def leaveEntrance(self, amount, destination):
    self.quantity -= amount
    print(f"{amount} people left entrance to {destination}")

  def externalArrival(self):
    arrivals = random.randint(5, 20)
    self.quantity += arrivals
    print(f"{arrivals} new people arrived at Entrance from outside")

  def externalDeparture(self):
    if self.quantity > 0:
      departures = min(random.randint(5, 20), self.quantity)  # Cannot remove more than available
      self.quantity -= departures
      print(f"{departures} people left Entrance to outside")

  def reportEntrance(self):
    print(f"currently {self.quantity} in Entrance")

class Metro:
  def __init__(self, initialPeople=100, maxCapacity=500):
    self.quantity = initialPeople
    self.maxCapacity = maxCapacity
    self.turnedAway = 0

  def enterMetro(self, amount, source):
    # Check if there's enough capacity
    availableSpace = self.maxCapacity - self.quantity
    accepted = min(amount, availableSpace)
    rejected = amount - accepted
    
    self.quantity += accepted
    self.turnedAway += rejected
    
    if rejected > 0:
      print(f"{accepted} people entered the Metro from {source}, {rejected} were turned away due to capacity limits")
    else:
      print(f"{accepted} people entered the Metro from {source}")
    
    return rejected  # Return the number of people turned away

  def leaveMetro(self, amount, destination):
    self.quantity -= amount
    print(f"{amount} people left Metro to {destination}")

  def externalArrival(self):
    arrivals = random.randint(5, 20)
    self.quantity += arrivals
    print(f"{arrivals} new people arrived at Metro from outside")

  def externalDeparture(self):
    if self.quantity > 0:
      departures = min(random.randint(5, 20), self.quantity)  # Cannot remove more than available
      self.quantity -= departures
      print(f"{departures} people left Metro to outside")

  def reportMetro(self):
    print(f"currently {self.quantity} in Metro (capacity: {self.maxCapacity})")

  def resetTurnedAway(self):
    turned = self.turnedAway
    self.turnedAway = 0
    return turned

class Cercanias:
  def __init__(self, initialPeople=100, maxCapacity=400):
    self.quantity = initialPeople
    self.maxCapacity = maxCapacity
    self.turnedAway = 0

  def enterCercanias(self, amount, source):
    # Check if there's enough capacity
    availableSpace = self.maxCapacity - self.quantity
    accepted = min(amount, availableSpace)
    rejected = amount - accepted
    
    self.quantity += accepted
    self.turnedAway += rejected
    
    if rejected > 0:
      print(f"{accepted} people entered the Cercanias from {source}, {rejected} were turned away due to capacity limits")
    else:
      print(f"{accepted} people entered the Cercanias from {source}")
    
    return rejected  # Return the number of people turned away

  def leaveCercanias(self, amount, destination):
    self.quantity -= amount
    print(f"{amount} people left Cercanias to {destination}")

  def externalArrival(self):
    arrivals = random.randint(5, 20)
    self.quantity += arrivals
    print(f"{arrivals} new people arrived at Cercanias from outside")

  def externalDeparture(self):
    if self.quantity > 0:
      departures = min(random.randint(5, 20), self.quantity)  # Cannot remove more than available
      self.quantity -= departures
      print(f"{departures} people left Cercanias to outside")

  def reportCercanias(self):
    print(f"currently {self.quantity} in Cercanias (capacity: {self.maxCapacity})")

  def resetTurnedAway(self):
    turned = self.turnedAway
    self.turnedAway = 0
    return turned

class TimeOfDay:
  def __init__(self):
    # Operating hours: 6:00 AM to 1:30 AM
    self.start_hour = 6.0  # 6:00 AM
    self.end_hour = 25.5   # 1:30 AM (next day)
    self.peak_hour = 17.0  # 5:00 PM
    # How many hours in the simulation (rounded up to ensure we have a full hour at the end)
    self.operating_hours = (self.end_hour - self.start_hour)
    # Calculate total number of cycles (one per hour)
    self.total_cycles = int(self.operating_hours) + 1  # +1 to include the final partial hour
    # Parameters for skewed normal distribution (right-skewed around 5pm)
    self.skew_param = 5    # Controls skewness, positive for right-skew
    self.loc_param = 17.0  # Location parameter (peak at 5pm)
    self.scale_param = 3.0 # Scale parameter (spread of distribution)
    
    # Generate all hours for the simulation
    self.hours = [self.start_hour + i for i in range(self.total_cycles)]

  def get_current_hour(self, cycle):
    # Each cycle represents one hour
    if cycle < len(self.hours):
      return self.hours[cycle]
    else:
      return None  # Invalid cycle

  def get_time_factor(self, hour):
    # If outside operating hours, return 0
    if hour < self.start_hour or hour > self.end_hour:
      return 0.0
    
    # Create a normalized position within the day for the skewed normal distribution
    normalized_hour = (hour - self.start_hour) / self.operating_hours
    
    # Use skewed normal distribution with peak around 5pm
    x = np.linspace(0, 1, 1000)
    pdf = stats.skewnorm.pdf(x, self.skew_param, loc=self.loc_param/24, scale=self.scale_param/24)
    
    # Normalize to ensure maximum is 1.0
    pdf_normalized = pdf / pdf.max()
    
    # Find the closest value in the distribution
    idx = int(normalized_hour * 1000)
    idx = max(0, min(idx, 999))  # Ensure index is within bounds
    
    return pdf_normalized[idx]

  def format_hour(self, hour):
    # Convert decimal hour to HH:MM format
    is_next_day = hour >= 24
    hour_adjusted = hour % 24
    
    hours = int(hour_adjusted)
    minutes = int((hour_adjusted - hours) * 60)
    
    if is_next_day:
      return f"{hours:02d}:{minutes:02d} (next day)"
    else:
      return f"{hours:02d}:{minutes:02d}"

class FlowTracker:
  def __init__(self):
    # Track people entering each entity
    self.metro_entries = {"Outside": 0, "Entrance": 0, "Cercanias": 0}
    self.entrance_entries = {"Outside": 0, "Metro": 0, "Cercanias": 0}
    self.cercanias_entries = {"Outside": 0, "Metro": 0, "Entrance": 0}
    
    # Track people leaving each entity
    self.metro_exits = {"Outside": 0, "Entrance": 0, "Cercanias": 0}
    self.entrance_exits = {"Outside": 0, "Metro": 0, "Cercanias": 0}
    self.cercanias_exits = {"Outside": 0, "Metro": 0, "Entrance": 0}
    
    # Track people turned away due to capacity
    self.metro_rejected = {"Entrance": 0, "Cercanias": 0, "Outside": 0}
    self.cercanias_rejected = {"Metro": 0, "Entrance": 0, "Outside": 0}
    
    # All time record for hourly data
    self.hourly_data = []
    
  def record_entry(self, entity, amount, source):
    if entity == "Metro":
      self.metro_entries[source] += amount
    elif entity == "Entrance":
      self.entrance_entries[source] += amount
    elif entity == "Cercanias":
      self.cercanias_entries[source] += amount
  
  def record_exit(self, entity, amount, destination):
    if entity == "Metro":
      self.metro_exits[destination] += amount
    elif entity == "Entrance":
      self.entrance_exits[destination] += amount
    elif entity == "Cercanias":
      self.cercanias_exits[destination] += amount
  
  def record_rejected(self, entity, amount, source):
    if entity == "Metro":
      self.metro_rejected[source] += amount
    elif entity == "Cercanias":
      self.cercanias_rejected[source] += amount
  
  def save_hourly_data(self, hour):
    # Create a deep copy of current data
    hourly_snapshot = {
      "hour": hour,
      "metro_entries": self.metro_entries.copy(),
      "entrance_entries": self.entrance_entries.copy(),
      "cercanias_entries": self.cercanias_entries.copy(),
      "metro_exits": self.metro_exits.copy(),
      "entrance_exits": self.entrance_exits.copy(),
      "cercanias_exits": self.cercanias_exits.copy(),
      "metro_rejected": self.metro_rejected.copy(),
      "cercanias_rejected": self.cercanias_rejected.copy()
    }
    self.hourly_data.append(hourly_snapshot)
    
    # Reset counters for the next hour
    self.metro_entries = {"Outside": 0, "Entrance": 0, "Cercanias": 0}
    self.entrance_entries = {"Outside": 0, "Metro": 0, "Cercanias": 0}
    self.cercanias_entries = {"Outside": 0, "Metro": 0, "Entrance": 0}
    self.metro_exits = {"Outside": 0, "Entrance": 0, "Cercanias": 0}
    self.entrance_exits = {"Outside": 0, "Metro": 0, "Cercanias": 0}
    self.cercanias_exits = {"Outside": 0, "Metro": 0, "Entrance": 0}
    self.metro_rejected = {"Entrance": 0, "Cercanias": 0, "Outside": 0}
    self.cercanias_rejected = {"Metro": 0, "Entrance": 0, "Outside": 0}

class PeopleGenerator:
  def __init__(self, arrival_rate=10, time_of_day=None):
    self.base_arrival_rate = arrival_rate  # Base expected average arrivals per cycle
    self.time_of_day = time_of_day

  def generate(self, hour):
    # If time_of_day is specified, use time-based generation
    if self.time_of_day:
      time_factor = self.time_of_day.get_time_factor(hour)
      
      # Scale arrival rate based on time of day
      adjusted_rate = self.base_arrival_rate * time_factor * 3.0  # Multiply by 3.0 to have peak times be busier
      
      # Ensure a minimum level of activity even during off-peak hours
      adjusted_rate = max(adjusted_rate, self.base_arrival_rate * 0.2)
      
      return random.randint(int(0.7 * adjusted_rate), int(1.3 * adjusted_rate))
    else:
      # If no time information provided, use the original generation method
      return random.randint(int(0.5 * self.base_arrival_rate), int(1.5 * self.base_arrival_rate))

class PeopleSink:
  def __init__(self, departure_rate=10, time_of_day=None):
    self.base_departure_rate = departure_rate  # Base expected average departures per cycle
    self.time_of_day = time_of_day

  def drain(self, current_population, hour):
    # If time_of_day is specified, use time-based draining
    if self.time_of_day:
      time_factor = self.time_of_day.get_time_factor(hour)
      
      # Scale departure rate based on time of day
      adjusted_rate = self.base_departure_rate * time_factor * 3.0  # Higher during peak hours
      
      # Ensure a minimum level of departures even during off-peak hours
      adjusted_rate = max(adjusted_rate, self.base_departure_rate * 0.2)
      
      # Ensure we don't remove more than available
      return min(random.randint(int(0.7 * adjusted_rate), int(1.3 * adjusted_rate)), current_population)
    else:
      # If no time information provided, use the original drain method
      return min(random.randint(int(0.5 * self.base_departure_rate), int(1.5 * self.base_departure_rate)), current_population)

class peopleFlowSimulation:
  def __init__(self, metro, cercanias, entrance,
               metro_gen=None, cercanias_gen=None, entrance_gen=None,
               metro_sink=None, cercanias_sink=None, entrance_sink=None,
               time_of_day=None):

    self.metro = metro
    self.cercanias = cercanias
    self.entrance = entrance
    self.time_of_day = time_of_day
    # Set cycles based on operating hours
    self.cycles = self.time_of_day.total_cycles if time_of_day else 24

    self.metro_gen = metro_gen or PeopleGenerator(15, time_of_day)
    self.cercanias_gen = cercanias_gen or PeopleGenerator(15, time_of_day)
    self.entrance_gen = entrance_gen or PeopleGenerator(15, time_of_day)

    self.metro_sink = metro_sink or PeopleSink(10, time_of_day)
    self.cercanias_sink = cercanias_sink or PeopleSink(10, time_of_day)
    self.entrance_sink = entrance_sink or PeopleSink(10, time_of_day)

    # Add tracking lists
    self.metro_history = []
    self.cercanias_history = []
    self.entrance_history = []
    self.metro_turned_away_history = []
    self.cercanias_turned_away_history = []
    self.time_history = []
    
    # Flow tracker
    self.flow_tracker = FlowTracker()

  def flow(self):
    for i in range(self.cycles):
      # Get the current hour for this cycle
      if self.time_of_day:
        current_hour = self.time_of_day.get_current_hour(i)
        if current_hour is None or current_hour > self.time_of_day.end_hour:
          continue  # Skip if outside operating hours
        
        hour_formatted = self.time_of_day.format_hour(current_hour)
        print(f"\n ========== Simulation Cycle {i} (Time: {hour_formatted}) ========== \n")
        self.time_history.append(current_hour)
      else:
        print(f"\n ========== Simulation Cycle {i} ========== \n")
        current_hour = i  # Just use cycle number as hour if no time system

      #Movements from outside the system in
      print("************************************************")
      metro_arrivals = self.metro_gen.generate(current_hour)
      entrance_arrivals = self.entrance_gen.generate(current_hour)
      cercanias_arrivals = self.cercanias_gen.generate(current_hour)

      # Apply capacity limits when people enter
      metro_rejected = self.metro.enterMetro(metro_arrivals, "Outside")
      self.flow_tracker.record_entry("Metro", metro_arrivals - metro_rejected, "Outside")
      self.flow_tracker.record_rejected("Metro", metro_rejected, "Outside")
      
      self.entrance.enterEntrance(entrance_arrivals, "Outside")
      self.flow_tracker.record_entry("Entrance", entrance_arrivals, "Outside")
      
      cercanias_rejected = self.cercanias.enterCercanias(cercanias_arrivals, "Outside")
      self.flow_tracker.record_entry("Cercanias", cercanias_arrivals - cercanias_rejected, "Outside")
      self.flow_tracker.record_rejected("Cercanias", cercanias_rejected, "Outside")
      
      print("************************************************")

      #probability definitions (same as before)...
      metroToMetro = int(self.metro.quantity * 0.45)
      metroToCercanias = int(self.metro.quantity * 0.25)
      metroToEntrance = int(self.metro.quantity * 0.30)

      entranceToEntrance = int(self.entrance.quantity * 0.03)
      entranceToMetro = int(self.entrance.quantity * 0.776)
      entranceToCercanias = int(self.entrance.quantity * 0.194)

      cercaniasToCercanias = int(self.cercanias.quantity * 0.02)
      cercaniasToMetro = int(self.cercanias.quantity * 0.588)
      cercaniasToEntrance = int(self.cercanias.quantity * 0.392)

      # Movement logic with capacity limits and flow tracking...
      if self.metro.quantity >= metroToMetro:
        print(f"{metroToMetro} people stayed in Metro")
      
      if self.metro.quantity >= metroToCercanias:
        self.metro.leaveMetro(metroToCercanias, "Cercanias")
        self.flow_tracker.record_exit("Metro", metroToCercanias, "Cercanias")
        
        cercanias_rejected = self.cercanias.enterCercanias(metroToCercanias, "Metro")
        self.flow_tracker.record_entry("Cercanias", metroToCercanias - cercanias_rejected, "Metro")
        self.flow_tracker.record_rejected("Cercanias", cercanias_rejected, "Metro")
      
      if self.metro.quantity >= metroToEntrance:
        self.metro.leaveMetro(metroToEntrance, "Entrance")
        self.flow_tracker.record_exit("Metro", metroToEntrance, "Entrance")
        
        self.entrance.enterEntrance(metroToEntrance, "Metro")
        self.flow_tracker.record_entry("Entrance", metroToEntrance, "Metro")

      if self.entrance.quantity >= entranceToEntrance:
        print(f"{entranceToEntrance} people stayed in Entrance")
      
      if self.entrance.quantity >= entranceToMetro:
        self.entrance.leaveEntrance(entranceToMetro, "Metro")
        self.flow_tracker.record_exit("Entrance", entranceToMetro, "Metro")
        
        metro_rejected = self.metro.enterMetro(entranceToMetro, "Entrance")
        self.flow_tracker.record_entry("Metro", entranceToMetro - metro_rejected, "Entrance")
        self.flow_tracker.record_rejected("Metro", metro_rejected, "Entrance")
      
      if self.entrance.quantity >= entranceToCercanias:
        self.entrance.leaveEntrance(entranceToCercanias, "Cercanias")
        self.flow_tracker.record_exit("Entrance", entranceToCercanias, "Cercanias")
        
        cercanias_rejected = self.cercanias.enterCercanias(entranceToCercanias, "Entrance")
        self.flow_tracker.record_entry("Cercanias", entranceToCercanias - cercanias_rejected, "Entrance")
        self.flow_tracker.record_rejected("Cercanias", cercanias_rejected, "Entrance")

      if self.cercanias.quantity >= cercaniasToCercanias:
        print(f"{cercaniasToCercanias} people stayed in Cercanias")
      
      if self.cercanias.quantity >= cercaniasToMetro:
        self.cercanias.leaveCercanias(cercaniasToMetro, "Metro")
        self.flow_tracker.record_exit("Cercanias", cercaniasToMetro, "Metro")
        
        metro_rejected = self.metro.enterMetro(cercaniasToMetro, "Cercanias")
        self.flow_tracker.record_entry("Metro", cercaniasToMetro - metro_rejected, "Cercanias")
        self.flow_tracker.record_rejected("Metro", metro_rejected, "Cercanias")
      
      if self.cercanias.quantity >= cercaniasToEntrance:
        self.cercanias.leaveCercanias(cercaniasToEntrance, "Entrance")
        self.flow_tracker.record_exit("Cercanias", cercaniasToEntrance, "Entrance")
        
        self.entrance.enterEntrance(cercaniasToEntrance, "Cercanias")
        self.flow_tracker.record_entry("Entrance", cercaniasToEntrance, "Cercanias")

      # External departures
      print("************************************************")
      metro_departures = self.metro_sink.drain(self.metro.quantity, current_hour)
      entrance_departures = self.entrance_sink.drain(self.entrance.quantity, current_hour)
      cercanias_departures = self.cercanias_sink.drain(self.cercanias.quantity, current_hour)

      self.metro.leaveMetro(metro_departures, "Outside")
      self.flow_tracker.record_exit("Metro", metro_departures, "Outside")
      
      self.entrance.leaveEntrance(entrance_departures, "Outside")
      self.flow_tracker.record_exit("Entrance", entrance_departures, "Outside")
      
      self.cercanias.leaveCercanias(cercanias_departures, "Outside")
      self.flow_tracker.record_exit("Cercanias", cercanias_departures, "Outside")
      
      print("************************************************")

      # Save populations for plotting
      self.metro_history.append(self.metro.quantity)
      self.cercanias_history.append(self.cercanias.quantity)
      self.entrance_history.append(self.entrance.quantity)
      
      # Save the current hour's flow data before moving to next cycle
      self.flow_tracker.save_hourly_data(current_hour)

      # Report
      print("===========================================")
      self.metro.reportMetro()
      self.cercanias.reportCercanias()
      self.entrance.reportEntrance()
      print("===========================================")

  def plot_results(self):
    # Create figure with multiple subplots
    fig, ax = plt.subplots(figsize=(14, 6))
    
    # Population over time
    ax.plot(self.time_history, self.metro_history, label="Metro", color='blue')
    ax.plot(self.time_history, self.cercanias_history, label="Cercanias", color='green')
    ax.plot(self.time_history, self.entrance_history, label="Entrance", color='orange')
    
    # Format x-axis with time labels
    time_ticks = np.linspace(0, len(self.time_history)-1, min(10, len(self.time_history)), dtype=int)
    if len(time_ticks) > 0:
      time_labels = [self.time_of_day.format_hour(self.time_history[i]) for i in time_ticks]
      ax.set_xticks([self.time_history[i] for i in time_ticks])
      ax.set_xticklabels(time_labels, rotation=45)
    
    ax.set_title("Population at Sol Station Over Time")
    ax.set_xlabel("Time of Day")
    ax.set_ylabel("Number of People")
    ax.legend()
    ax.grid(True)
    
    plt.tight_layout()
    plt.show()
    
    # Create bar charts for flow analysis
    self.plot_flow_charts()
    
  def plot_flow_charts(self):
    # Extract flow data from hours 8:00, 12:00, 17:00, and 22:00 for comparison
    target_hours = [8.0, 12.0, 17.0, 22.0]
    selected_data = []
    
    for hour in target_hours:
      # Find the closest data point to the target hour
      closest_idx = None
      min_diff = float('inf')
      
      for i, data in enumerate(self.flow_tracker.hourly_data):
        diff = abs(data["hour"] - hour)
        if diff < min_diff:
          min_diff = diff
          closest_idx = i
      
      if closest_idx is not None and min_diff < 1.0:  # Only use if within 1 hour
        data = self.flow_tracker.hourly_data[closest_idx]
        selected_data.append({
          "hour": data["hour"],
          "formatted_hour": self.time_of_day.format_hour(data["hour"]),
          "data": data
        })
    
    # Create bar charts for each selected hour
    for hour_data in selected_data:
      self.create_entity_flow_chart(hour_data)
      
  def create_entity_flow_chart(self, hour_data):
    hour = hour_data["hour"]
    formatted_hour = hour_data["formatted_hour"]
    data = hour_data["data"]
    
    # Create figure with 3 subplots (one for each entity)
    fig, (ax1, ax2, ax3) = plt.subplots(1, 3, figsize=(18, 6))
    
    # Setup colors for different sources/destinations
    colors = {
      'Outside': 'gray', 
      'Metro': 'blue', 
      'Entrance': 'orange', 
      'Cercanias': 'green',
      'Rejected': 'red'
    }
    
    # Plot for Metro
    self.plot_entity_flows(
      ax1, 
      "Metro", 
      data["metro_entries"], 
      data["metro_exits"], 
      data["metro_rejected"],
      colors
    )
    
    # Plot for Entrance
    self.plot_entity_flows(
      ax2, 
      "Entrance", 
      data["entrance_entries"], 
      data["entrance_exits"], 
      {},  # No capacity limits for entrance
      colors
    )
    
    # Plot for Cercanias
    self.plot_entity_flows(
      ax3, 
      "Cercanias", 
      data["cercanias_entries"], 
      data["cercanias_exits"], 
      data["cercanias_rejected"],
      colors
    )
    
    # Set title for the entire figure
    fig.suptitle(f"People Flow Analysis at {formatted_hour}", fontsize=16)
    plt.tight_layout()
    plt.subplots_adjust(top=0.88)  # Make room for the title
    plt.show()
    
  def plot_entity_flows(self, ax, entity_name, entries, exits, rejected, colors):
    # Bar width
    width = 0.35
    
    # Get the sources and destinations
    sources = list(entries.keys())
    destinations = list(exits.keys())
    
    # Get the values
    entry_values = [entries[src] for src in sources]
    exit_values = [exits[dest] for dest in destinations]
    
    # Setup x positions
    x_pos_entries = np.arange(len(sources))
    x_pos_exits = np.arange(len(destinations)) + len(sources) + 1  # Add space between groups
    
    # Plot inflows
    entry_bars = ax.bar(x_pos_entries, entry_values, width, label='Entries', color=[colors[src] for src in sources])
    
    # Plot outflows
    exit_bars = ax.bar(x_pos_exits, exit_values, width, label='Exits', color=[colors[dest] for dest in destinations])
    
    # If there are rejected entries, plot them
    if rejected:
      x_pos_rejected = np.arange(len(rejected)) + len(sources) + len(destinations) + 2
      rejected_values = [rejected[src] for src in rejected.keys()]
      rejected_bars = ax.bar(x_pos_rejected, rejected_values, width, label='Rejected', color='red')
      
      # Add rejected labels
      ax.set_xticks(np.concatenate([x_pos_entries, x_pos_exits, x_pos_rejected]))
      ax.set_xticklabels(sources + destinations + [f"Rej: {src}" for src in rejected.keys()], rotation=45)
    else:
      # No rejected entries
      ax.set_xticks(np.concatenate([x_pos_entries, x_pos_exits]))
      ax.set_xticklabels(sources + destinations, rotation=45)
    
    # Add labels and title
    ax.set_ylabel('Number of People')
    ax.set_title(f'{entity_name} Flow')
    
    # Add value labels on top of each bar
    for bar in entry_bars + exit_bars:
      height = bar.get_height()
      ax.text(bar.get_x() + bar.get_width()/2., height + 5,
              f'{int(height)}', ha='center', va='bottom')
    
    # Add a legend
    ax.legend()

# Set up time of day
time_system = TimeOfDay()

# Create station components with capacity limits
metro1 = Metro(100, maxCapacity=500)
entrance1 = Entrance(100)
cercanias1 = Cercanias(100, maxCapacity=400)

# Create people generators and sinks with time-of-day awareness
metro_gen = PeopleGenerator(arrival_rate=40, time_of_day=time_system)
entrance_gen = PeopleGenerator(arrival_rate=30, time_of_day=time_system)
cercanias_gen = PeopleGenerator(arrival_rate=35, time_of_day=time_system)

metro_sink = PeopleSink(departure_rate=35, time_of_day=time_system)
entrance_sink = PeopleSink(departure_rate=25, time_of_day=time_system)
cercanias_sink = PeopleSink(departure_rate=30, time_of_day=time_system)

# Create simulation with time-of-day awareness, removing the cycles parameter
simulation1 = peopleFlowSimulation(
    metro1, cercanias1, entrance1,
    metro_gen, cercanias_gen, entrance_gen,
    metro_sink, cercanias_sink, entrance_sink,
    time_of_day=time_system
)

simulation1.flow()
simulation1.plot_results()